{"posts":[{"title":"Vue项目启动后的入口","content":"背景 最近一直在学Vue，因为突然被转到了前端的项目。作为一个iOS开发，突然上手Vue项目还是有点不知所措的。在一系列装环境、运行、调试等操作后，项目终于运行了。在终端输出里也出现地址。打开浏览器输入地址后，出现了登录页面。可是看了工程目录后，发现目录中只有一个index.html。所以就引入一个问题，在工程跑起来后，是怎么找到index.html这个文件呢。 vue-cli 经过我各种百度、谷歌。发现大家的问题都是在问App.vue、main.js、index.html的关系。并没有直接说明为什么入口是index.html。从解答也能看出来，首先vue项目是运行在vue-cli(command line interface)上，从官方文档上看，vue-cli是基于 webpack 构建的。并带有一些默认webpack配置。而项目运行后的首页，也就是index.html和工程里的index.html是不同的。工程里的index.html只是一个模版，通过webpack中的一个plugin(html-webpack-plugin)把作为入口的main.js文件(main.js文件里会有调用用App.vue里的代码)注入到了工程里的index.html文件中。工程中的index.html作为一个模版是可以更改的。在vue.config.js中可以通过配置webpack的plugin配置来设置template路径。 总结:vue-cli是基于webpack的。通过vue-cli中的html-webpack-plugin，可以将项目中的App.vue、main.js、index.html关联起来，生成一个index.html。而工程运行后，浏览器显示的html也就是这个生成的index.html。 webpack-dev-server 现在知道了项目运行后的入口index.html的来源，可是为什么浏览器输入后地址后，会跳到index.html中呢？ 其实这是分为两种情况。第一个种情况是，vue项目进行打包后。打包后会生成dist文件夹。这个dist文件夹内有index.html。当dist文件夹被部署后，浏览器会跳转到index.html这个都是有服务器配置来决定。比如Nginx，Apache等。第二种是常见的情况，就是本地调试。之所以会跳转到index.html，是因为vue-cli中用了webpack-dev-server。而正是这个webpack-dev-server在本地启动了服务类似Nginx、Apach这种服务器。webpack-dev-server默认配置会启动项目中的index.html。如果需要配置在vue.config.js中进行配置就可以。 总结:在执行完npm run server后，vue-cli会通过webpack-dev-server在后台创建一个服务。当在浏览器器输入地址后，这个服务会收到请求，将本地目录中的index.html(此时的index.html已经是经过html-webpack-plugin处理生成的index.html)返回给浏览器，浏览器收到返回的index.html后进行渲染。 ","link":"http://localhost:4000/post/vue-xiang-mu-qi-dong-hou-de-ru-kou/"},{"title":"Https理解","content":"HPPTS是HTTP+SSL/TLS的简称 SSL是基于HTTP之下TCP之上的一个协议层 TLS是SSL更新到3.0后，对SSL的一个更新。可以被认为是SSL3.1 常见的 非对称加密：RSA 对称加密：AES、DES Hash算法：MD5、SHA1、SHA256 流程： 1.客户端向服务端发起请求，服务端返回了证书 2.客户端验证证书，生成随机数作为密钥，并用证书中的公钥加密，传给服务端 3.服务端用私钥解密，并用hash验证数据。两端通信将用随机数密钥来加解密。 ","link":"http://localhost:4000/post/https-li-jie/"},{"title":"重装电脑后配置环境","content":"1.Xcode 2.VS Code 3.homebrew /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot; 4.安装rvm 5.安装Ruby rvm install 版本 Rvm use 版本 --default 6.更换Gem Sources gem sources -r https://rubygems.org/ gem sources -a https://gems.ruby-china.com/ 7.安装cocoapods sudo gem install cocoapods 8.RSA生成公私钥 ssh-keygen -t rsa -b 4096 -C &quot;44934776@qq.com&quot; pbcopy &lt; ~/.ssh/id_rsa.pub ","link":"http://localhost:4000/post/chong-zhuang-dian-nao-hou-pei-zhi-huan-jing/"},{"title":"Block","content":"Block在内存上的分配 Block如果访问了外部变量，则属于Stack Block Block如果没有访问外部变量，则属于Global Block 对Stack Block执行Copy 操作 则属于Heap Block ARC会有一下情况对Stack Block进行copy操作： 1.Block作为函数值返回 2.Block用strong指针指向 3.Block作为系统函数中比如using block 4.Block在GCD的参数中 Block捕获外部变量 局部变量是会被Block捕获。 静态局部变量被Block捕获后是通过指针来传递的。 普通局部变量被捕获后是通过值来传递的。 全局变量不会被Block捕获。 被__block修饰的变量。被Block捕获后，会生成一个结构体。 结构体里有个forwarding指针，指向了结构体。 当Block被copy时，也会对捕获的变量进行copy。 如果捕获的变量是__weak，也不会形成强引用。 Retain修饰的Block MRC下Block不用retain修饰的原因是，用retain修饰会使引用计数+1，但不会生成新的对象。因此在使用Block时，Block有可能已经被释放。因此需要用copy修饰。ARC，无论strong还是copy，系统都会对Block做copy操作，将栈Block拷贝到堆。 ","link":"http://localhost:4000/post/block/"},{"title":"Xcode-select","content":"我们的Xcode使用版本可以根据Xcode &gt; Preferences &gt; Locations路径查看到正在使用的版本和该版本路径。 在终端xcode-select可使用的命令如下: xcode-select [-h, –help] xcode-select [-p, –print-path] xcode-select [-s , –switch ] xcode-select [-v, –version] xcode-select [-r, –reset ] 查看xcode-select可使用命令，使用如下命令 xcode-select -h xcode-select --help 查看当前正在使用的Xcode版本路径，使用如下命令 xcode-select -p xcode-select --print-path 查看xcode-select版本 xcode-select -v xcode-select --version 重置为默认的command line tools path xcode-select -r xcode-select -reset 修改Xcode使用版本 sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer sudo xcode-select -s /Applications/Xcode.app/Contents/Developer ","link":"http://localhost:4000/post/xcode-select/"},{"title":"Runtime应用","content":"方法交换 之前一直知道通过runtime中的方法可以进行方法交换，可是一直没有实际写过。所以写个demo。 #import &lt;objc/runtime.h&gt; 交换方法需要在load函数里做 1.获取两个方法的实现 Method imageNameMethod = class_getClassMethod(self, @selector(imageNamed:)); Method yh_imageWithNameMethod = class_getClassMethod(self, @selector(yh_imageWithName:)); 2.交换方法实现 method_exchangeImplementations(imageNameMethod, yh_imageWithNameMethod); 注意的地方： 1.方法交换一般是在load函数里做。 2.在新写的方法里如果需要执行老的方法时，调用的时候[self 新名字]。 3.分类的方法交换也是全局生效，不是引用分类文件的地方生效。不要误以为没有加入头文件，方法交换就不生效了。 分类增加属性 #import &lt;objc/runtime.h&gt; 重写getter和setter的方法 static const void *testKey = &amp;testKey; - (void)setIsTest:(BOOL)isTest { objc_setAssociatedObject(self, testKey, [NSNumber numberWithBool:isTest], OBJC_ASSOCIATION_ASSIGN); } - (BOOL)isTest { return [objc_getAssociatedObject(self, testKey) boolValue]; } 解释一下static const void *testKey = &amp;testKey;这么写的原因 void *代表着无类型指针，也就是任何类型的指针都可以给它赋值。而&amp;代表这取址运算符，因此这句话的含义就是将testKey的地址赋给testKey。 此外还有两种方式来写key值 static NSString *key = @&quot;key&quot;; static char key; ","link":"http://localhost:4000/post/runtime-ying-yong/"},{"title":"Runtime学习","content":" 类本身是一个描述, 描述里包含实例化这个类需要多大的内存, 以及内存的每个byte是什么内容, 这个内容的头部是一个isa, 其他内容是ivar的值或指针. 对象是按类的描述所从内存空间里面开辟出对应大小的空间并填充isa指针(alloc), 类的初始化方法往这个空间里的byte里面存初始化的内容. 实例化的对象本质是 iOS中所有类都继承NSObject NSObject 是一个包含着isa指针的类 那NSObject又是什么呢？ 可以看到，根据苹果官方的注释，只要符合objc_object的结构即是一个对象，因此可以这么理解，只要是包含isa（Class类型）的结构体指针他就是一个对象。 根据注释发现Class代表着一个类，而NSObject就是一个Class，而Class类型是objc_class。 可以看到objc_class也拥有着isa（Class类型），因此可以导出NSObject是一个Class，而Class是一个对象，因此NSObject是一个对象。 同理按照定义，只要类型是一个包含isa（Class类型）的结构体指针，那么它就是一个对象。 一个NSObject对象占用多少内存？ 一个指针变量所占用的大小（64bit占8个字节，32bit占4个字节） ","link":"http://localhost:4000/post/runtime-xue-xi/"},{"title":"ReactNative学习","content":"React Naitve 指令 react-native init MyApp --version 0.44.3 npm install 安装module react-native run-ios --simulator 'iPhone 8' npm start 开启服务 npm update -g react-native-cli 更新react-native环境 npm install --save react-native@0.44.3 安装指定版本的react native react-native upgrade 更新项目文件 npm install realm 安装对应的库 react-native link 链接对应的库 npm uninstall react-native-video 删除对应的库文件 ReactRedux Dispatch Action -&gt; reducer处理state-&gt; Provider接收到变化的State-&gt;setState（dummyState）-&gt;connect的组件触发componentWillReceiveProps-&gt;进行props判断，如果判断有变化-&gt;更新子组件props-&gt;触发子组件的Render。 FlatList遇到的问题 上拉加载会触发 onEndReached FlatList触发onEndReached的时机是： 1._onContentSizeChange 2._onScroll 3._onLayout 现象是上拉加载会触发两次onEndReached 排除了1，3，因此是上拉加载时触发了两次_onScroll （_onScroll时ScrollView的回调函数，只要滑动则调用。） onEndReached被包了一层（_maybeCallOnEndReached），因此从源码看出是有条件的被触发 现在解释上拉加载触发两次onEndReached的原因： 上拉加载----&gt;触发_onScroll----&gt;满足条件----&gt;触发onEndReached（在此时页面仍然是被滑动的，因此仍然会触发_onScroll）----&gt;同时又满足条件----&gt;又触发了onEndReacher 再解释一下，代码如下时上拉加载会触发一次onEndReached的原因 上拉加载----&gt;触发_onScroll----&gt;满足条件----&gt;触发onEndReached（在此时页面仍然是被滑动的，因此仍然会触发_onScroll）----&gt;而此时条件是不被满足的，因此不会触发onEndReacher 那满足的onEndReacher的条件是什么？ 经过调试发现，this._hasDataChangedSinceEndReached是导致两次现象不同的变量。 可以看到这个变量在componentWillReceiveProps的时候被赋值，因此是在网络请求后，FlatList的datesource会被改变，因此可以满足触发onEndReacher的条件，而触发一次onEndReacher的原因是，在网络请求后，数据没有被更新，这个变量为false，因此不满足条件。 解决方案： 现在目前的触发场景：上拉加载----&gt;触发_onScroll----&gt;满足条件----&gt;触发onEndReached（在此时页面仍然是被滑动的，因此仍然会触发_onScroll）----&gt;同时又满足条件----&gt;又触发了onEndReacher，因此只要切段第二次的满足条件，即可。原理就是加状态位控制。 ReactNative 颜色写法 以下这些格式的颜色代码都是支持的： '#f0f' (#rgb) '#f0fc' (#rgba) '#ff00ff' (#rrggbb) '#ff00ff00' (#rrggbbaa) 'rgb(255, 255, 255)' 'rgba(255, 255, 255, 1.0)' 'hsl(360, 100%, 100%)' 'hsla(360, 100%, 100%, 1.0)' 'transparent' 'red' 0xff00ff00 (0xrrggbbaa) Flux &amp;&amp; Redux Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。 Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。 Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。 store.dispatch()是 View 发出 Action 的唯一方法 Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。 ","link":"http://localhost:4000/post/reactnative-xue-xi/"},{"title":"Python学习","content":" Python2 中文编码 #coding=utf-8 ","link":"http://localhost:4000/post/python-xue-xi/"},{"title":"OSI模型","content":"OSI是一个试图使各种计算机在世界范围内互连为网络的标准框架，它将网络体系划分为7层，分为： 7.应用层 6.表达层 5.会话层 4.传输层 3.网络层 2.数据链路层 1.物理层 越靠下，就越接近硬件，且每一层都定义了许多协议，而这些协议的总称就是互联网协议（Internet Protocol Suite），大家都遵守了这些协议就可以完成通讯，从而构建起来互联网。 其中TCP/IP是其中一些协议的总称，被称为协议簇，而TCP/IP将通信过程简化并抽象成4层： 4.应用层 3.传输层 2.网络互联层 1.网络接口层 TCP/IP协议簇包含了以下比较常见的协议 下面就按照每一层的顺序来讲一下常见的协议： 物理层：也就是实体层，为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。简单的说，物理层确保原始的数据可在各种物理媒体上传输。规定了网络的一些电气特性，作用是负责传送0和1的电信号。 数据链路层：在实体层中定义了电信号，而链路层则是将这些电信号进行规范，Ethernet协议规定，一组电信号构成一个数据包，叫&quot;帧&quot;（Frame）。每一帧分成两个部分：标头（Head）和数据（Data），而标头里又包含数据包的一些说明项，比如发送者、接受者、数据类型等等；&quot;数据&quot;则是数据包的具体内容。发送者和接受者又通过MAC（Media Access Control）地址来标识，MAC地址是48个二进制位构成，可以标识网卡的唯一性。可以简单的说数据链路层的协议确定了MAC地址，有了MAC地址，发送端又会通过广播（Broadcast）方式向网络内所有的计算机发送数据，每台计算通过判断数据包里的MAC地址是否符合选择是否接受。 网络层：网络层提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，并具有一定的拥塞控制和流量控制的能力。由于TCP/IP协议体系中的网络层功能由IP协议规定和实现，故又称IP层。紧紧的依靠MAC地址是无法在不同一个子网络的的计算机进行传输，因为，网络区域被区分为多个子网络，不同子网络的计算机是无法知道对方计算机的MAC地址，因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用&quot;路由&quot;方式发送。因此，此层确定的协议IP协议（Internet Protocol）所定义的地址IP地址，用IP地址就可以确定子网络的位置，目前广泛采用的网络协议是IP协议的第四版，成为IPv4，这个版本规定了IP地址由32个二进制位组成。IP地址分为两部分，前一部分代表网络，后一部分代表主机。比如IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。网络部分和主机部分又是通过什么来区分的呢，通过子网掩码(Subnet Mask)来区分。所谓&quot;子网掩码&quot;，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。知道&quot;子网掩码&quot;，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。IP协议所发送的数据包也包含了两个部分：标头（Head）和数据（Data），而这个IP数据包被插入到了以太网数据包中的数据部分中。 数据链路层发送的数据包中包含了MAC地址，可是我们又如何来确定MAC地址，此时通过网络层中的ARP协议（Adress Resolution Protocol）就可以确定自网络内中的主机MAC地址，ARP协议通过广播的方式发送一个MAC地址为FF:FF:FF:FF:FF:FF的数据包，当子网络内的主机收到数据包判断数据包里的IP地址和自己的的IP地址相同时，便发送自己的MAC地址。 那IP地址又是如何来确定的，会在应用层说 传输层：当有了MAC地址和IP地址后，我们可以进行主机与主机的通信，但是如果是主机间的应用的通信又该如何确定呢，而此层定义的UDP协议则通过加入端口（Port）参数，就可以确定是哪个应用来通信，端口是0到65535的整数，正好是16个2进制位，0到1023被系统所占用，因此应用只能选用1023之后的端口号。加入了端口参数，就有了新的数据包，而UDP数据包也是有标头和数据组成，而UDP数据包被放到了IP数据包中的数据部分中。 Http和Socket连接区别 socket连接: 建立起一个TCP连接需要经过“三次握手”： 第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认； 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。 握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”。 socket连接就是所谓的长连接，理论上客户端和服务器端一旦加你其连接将不会主动断掉；但是由于各种环境因素可能会连接断开，比如说：服务器端或客户端主机down了，网络故障，或者两者之间长时间没有传输数据，网络防火墙可能会断开该连接以释放网络资源。所以当一个socket连接中没有数据传输的时候，那么为了维持连接需要发送心跳消息，具体心跳消息格式是开发者自己定义的。 HTTP连接: HTTP协议即超文本传送协议(HypertextTransfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。 HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。 1）在HTTP 1.0中，客户端的每次请求都要求建立一次单独的连接，在处理完本次请求后，就自动释放连接。 2）在HTTP 1.1中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行，不需要等待一个请求结束后再发送下一个请求。 由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。通常的 做法是即时不需要获得任何数据，客户端也保持每隔一段固定的时间向服务器发送一次“保持连接”的请求，服务器在收到该请求后对客户端进行回复，表明知道客户端“在线”。若服务器长时间无法收到客户端的请求，则认为客户端“下线”，若客户端长时间无法收到服务器的回复，则认为网络已经断开。 ","link":"http://localhost:4000/post/osi-mo-xing/"},{"title":"Node杂项","content":"Module 在 Node.js 模块系统中，每个文件都视为独立的模块。 在每个模块中，module 的自由变量是一个指向表示当前模块的对象的引用。 为了方便，module.exports 也可以通过全局模块的 exports 对象访问。 module 实际上不是全局的，而是每个模块本地的。实际上总会执行module.exports = exports util.inherits util.inherits(constructor, superConstructor)是一个实现对象间原型继承 的函数。 JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。 继承只能继承在原型中定义的函数，而构造函数内部是不被继承的。 ","link":"http://localhost:4000/post/node-za-xiang/"},{"title":"JavaScript杂项","content":"timeout timeout是可选参数 handle = window . setTimeout( handler [, timeout [, arguments... ] ] ) handle = window . setTimeout( code [, timeout ] ) 至于不写timeout参数，相当于timeout为0。 Let timeout be the second method argument, or zero if the argument was omitted. 但是timeout为0并不等于立即执行，实际的执行时间可能会受到其他执行的脚本，用户界面的刷新操作等等的影响 w3链接 关于timeout是否可以不填的问题链接 JS selector 空格：(′parentchildchild′)表示获取parent下的所有的childchild节点，所有的子孙。大于号：(&#x27;parent childchild&#x27;)表示获取parent下的所有的childchild节点，所有的子孙。 大于号：(′parentchildchild′)表示获取parent下的所有的childchild节点，所有的子孙。大于号：('parent &gt; child')表示获取parent下的所有child的儿子，第一代。 加号：(′pre+nextbrother′)表示获得pre节点的下一个兄弟节点，相当于next()方法波浪号：(&#x27;pre + nextbrother&#x27;)表示获得pre节点的下一个兄弟节点，相当于next()方法 波浪号：(′pre+nextbrother′)表示获得pre节点的下一个兄弟节点，相当于next()方法波浪号：('pre ~ brother')表示获取pre节点的后面的所有兄弟节点，相当于nextAll()方法。 JS闭包 阮一峰 prototype 1.每个对象都具有一个名为__proto__的属性； 2.每个构造函数（构造函数标准为大写开头，如Function()，Object()等等JS中自带的构造函数，以及自己创建的）都具有一个名为prototype的方法（注意：既然是方法，那么就是一个对象（JS中函数同样是对象），所以prototype同样带有__proto__属性）； 3.每个对象的__proto__属性指向自身构造函数的prototype； 函数也是对象，被称为函数对象。 函数对象有prototype属性，普通的对象没有该属性。 所有的对象都有__proto__属性。 原型对象就是prototype的值，也是一个拥有一些属性的对象。这些属性可能是浏览器增加的，也有自己手动加的。 如果实现继承，则直接修改原型对象，将原型对象直接改成需要继承的对象（通过构造函数生成）。 原型对象与其他对象不同的是，会有一个constructor属性。 constructor的值是prototype所在的函数（不是原型对象）。 __proto__指向的是对象构造函数的prototype。 Object.prototype.__proto__是null，因为Object.prototype在原型链的最顶层。 所有的函数对象的__proto__指向的是Function.prototype,它是一个空函数。 而原型链指的是从对象的__proto__开始查找直到找到Object.prototype.__proto__。 function本质上也是一个对象，但是function对象与普通对象相比，其内部有一个[[Call]]方法，用来表示这个对象是可调用的，typeof操作符在判断Object时，如果内部实现了[[Call]]方法,就返回function。 附上typeof操作符返回判断图： 这就能解释为什么typeof Function.prototype返回的是function，因为Function.prototype实现了call方法。 JS中的Bool转换 ","link":"http://localhost:4000/post/javascript-za-xiang/"},{"title":"iPhone尺寸表","content":"做iOS开发的可不能不知道iPhone的尺寸啊。 PaintCode链接 ","link":"http://localhost:4000/post/iphone-chi-cun-biao/"},{"title":"iOS中的Spring过渡动画效果","content":"Spring Animation 是一种特殊的动画曲线，自从 iOS 7 开始被广泛应用在系统动画中。 Spring Animation 在系统中的效果如下： 事实上，从 iOS 7 起几乎所有的系统动画都用的是 Spring Animation，包括 App 文件夹打开/关闭效果、键盘弹出效果、UISwitch 控件的开关效果、不同 View Controller 之间的 Push 动画、Modal 出现和消失的动画、Siri 的出现和消失动画，等等。 下图为 Spring Animation 和普通的动画的运动曲线的对比： 为了更加直观，我做了一组演示图，从左至右分别列出了 Spring Animation, Ease-Out Animation 和 Linear Animation 的动画效果： 和系统自带的 ease-out 效果相比，Spring Animation 前期速度增加得更快，在动画时间一定的前提下，给人感觉更加快速、干净。 自 iOS 8 开始，Apple 公开了 Spring Animation 的 API，开发者也可以使用简单的代码创建这类动画效果了： + (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion 该方法是UIView的类方法。 Spring Animation 的 API 和一般动画相比多了两个参数，分别是usingSpringWithDamping和initialSpringVelocity。 usingSpringWithDamping 参数 usingSpringWithDamping的范围为0.0f到1.0f，数值越小「弹簧」的振动效果越明显。下图演示了在initialSpringVelocity为0.0f的情况下，usingSpringWithDamping分别取0.2f，0.5f和1.0f的情况。 initialSpringVelocity 参数 initialSpringVelocity则表示初始的速度，数值越大一开始移动越快。下图演示了在usingSpringWithDamping为1.0f时，initialSpringVelocity分别取5.0f，15.0f和25.0f的情况。值得注意的是，初始速度取值较高而时间较短时，也会出现反弹情况。 使用 Spring Animation 是线性动画或 ease-out 动画的理想替代品。由于 iOS 本身大量使用的就是 Spring Animation，用户已经习惯了这种动画效果，因此使用它能使 App 让人感觉更加自然，用 Apple 的话说就是「instantly familiar」。此外，Spring Animation 不只能对位置使用，它适用于所有可被添加动画效果的属性。 ","link":"http://localhost:4000/post/ios-zhong-de-spring-guo-du-dong-hua-xiao-guo/"},{"title":"iOS中的load和initial","content":"load和initialize的共同点 如果父类和子类都被调用,父类的调用一定在子类之前 +load方法要点 当类被引用进项目的时候就会执行load函数(在main函数开始执行之前）,与这个类是否被用到无关,每个类的load函数只会自动调用一次.由于load函数是系统自动加载的，因此不需要再调用[super load]，否则父类的load函数会多次执行。 1.当父类和子类都实现load函数时,父类的load方法执行顺序要优先于子类 2.类中的load方法执行顺序要优先于类别(Category) 3.当有多个类别(Category)都实现了load方法,这几个load方法都会执行,但执行顺序不确定(其执行顺序与类别在Compile Sources中出现的顺序一致) 4.当然当有多个不同的类的时候,每个类load 执行顺序与其在Compile Sources出现的顺序一致 注意: load调用时机比较早,当load调用时,其他类可能还没加载完成,运行环境不安全. load方法是线程安全的，它使用了锁，我们应该避免线程阻塞在load方法. 每个类的load顺序不确定，所以load方法避免使用其他的类，因为其他类的load方法里可能会有一下重要的初始化方法，导致在使用时，这个类还没有被load。 +initialize方法要点 initialize在类或者其子类初始化时被调用。即使类文件被引用进项目,但是没有使用,initialize不会被调用。由于是系统自动调用，也不需要显式的调用父类的initialize，否则父类的initialize会被多次执行。假如这个类放到代码中，而这段代码并没有被执行，这个函数是不会被执行的。 1.父类的initialize方法会比子类先执行 2.当子类不实现initialize方法，会把父类的实现继承过来调用一遍。在此之前，父类的方法会被优先调用一次 3.当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个(会执行Compile Sources 列表中最后一个Category 的initialize方法) 注意: 在initialize方法收到调用时,运行环境基本健全。 initialize内部也使用了锁，所以是线程安全的。但同时要避免阻塞线程，不要再使用锁。同时iniitialize也应该避免调用其他了类，因为其他的类的初始化也有可能依赖这个这类的数据 ","link":"http://localhost:4000/post/ios-zhong-de-load-he-initial/"},{"title":"iOS中的isEqual","content":" ","link":"http://localhost:4000/post/ios-zhong-de-isequal/"},{"title":"iOS中的C对象","content":"C对象的释放 在 iOS 开发中经常遇见对 C 对象的处理，当使用 C 对象时，对象的内存管理将变成手动管理，可是 一般什么时候来进行对 C 对象的释放呢？ 苹果官方文档 ","link":"http://localhost:4000/post/ios-zhong-de-c-dui-xiang/"},{"title":"iOS中的响应链","content":"按照时间顺序，事件的生命周期是这样的： 事件的产生-&gt;事件的传递-&gt;事件的处理，其中重点和难点是： 如何寻找最合适的view 合适的view是如何处理的 iOS中的事件 iOS中的事件可以分为3大类型： 触摸事件 加速计事件 远程控制事件 这里我们只讨论iOS中的触摸事件。 响应者对象(UIResponder) 学习触摸事件首先要了解一个比较重要的概念-响应者对象（UIResponder）。 在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，我们称之为“响应者对象”。以下都是继承自UIResponder的，所以都能接收并处理事件。 UIApplication UIViewController UIView 那么为什么继承自UIResponder的类就能够接收并处理事件呢？ 因为UIResponder中提供了以下4个对象方法来处理触摸事件。 UIResponder内部提供了以下方法来处理事件触摸事件 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event; - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; 加速计事件 - (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event; - (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event; - (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event; 远程控制事件 - (void)remoteControlReceivedWithEvent:(UIEvent *)event; 事件的相关对象 UIView正是通过继承父类UIResponder的事件方法，从而具有了处理事件的能力。所以可以通过重写该方法来处理一些事件。 如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象。 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象。 重写以上四个方法，如果是处理UIView的触摸事件。必须要自定义UIView子类继承自UIView。 如果是处理UIViewController的触摸事件，那么在控制器的.m文件中直接重写那四个方法即可！ UITouch对象 当用户用一根手指触摸屏幕时，会创建一个与手指相关的UITouch对象。 一根手指对应一个UITouch对象。 如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan:withEvent:方法，touches参数中装着2个UITouch对象。 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan:withEvent:方法，并且每次调用时的touches参数中只包含一个UITouch对象。 UITouch的作用 保存着跟手指相关的信息，比如触摸的位置、时间、阶段。 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置。 当手指离开屏幕时，系统会销毁相应的UITouch对象。 UITouch的属性 触摸产生时所处的窗口 @property(nonatomic,readonly,retain) UIWindow *window; 触摸产生时所处的视图 @property(nonatomic,readonly,retain) UIView *view ; 短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击 @property(nonatomic,readonly) NSUInteger tapCount; 记录了触摸事件产生或变化时的时间，单位是秒 @property(nonatomic,readonly) NSTimeInterval timestamp; 当前触摸事件所处的状态 @property(nonatomic,readonly) UITouchPhase phase; UITouch的方法 (CGPoint)locationInView:(UIView *)view; // 返回值表示触摸在view上的位置 // 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)） // 调用时传入的view参数为nil的话，返回的是触摸点在UIWindow的位置 (CGPoint)previousLocationInView:(UIView *)view; // 该方法记录了前一个触摸点的位置 iOS中的事件的产生和传递 事件的产生 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中,为什么是队列而不是栈？因为队列的特点是FIFO，即先进先出，先产生的事件先处理才符合常理，所以把事件添加到队列。 UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。 找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。 事件的传递 触摸事件的传递是从父控件传递到子控件 也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view 注 意: 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件，应用如何找到最合适的控件来处理事件？判断逻辑如下： 首先判断主窗口（keyWindow）自己是否能接受触摸事件 判断触摸点是否在自己身上 子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后按照1、2步骤的方式来执行判断） 找到了这个合适的View后，再遍历这个View的子控件，直至没有更合适的view为止。如果没有符合条件的子控件，那么就认为自己最合适处理。 如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。 找到最合适的view后，就会调用该view的touches方法处理具体的事件。 UIView不能接收触摸事件的三种情况： 不允许交互：userInteractionEnabled = NO 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件 透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。 总结一下 点击一个UIView或产生一个触摸事件A，这个触摸事件A会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。 UIApplication会从事件对列中取出最前面的事件（此处假设为触摸事件A），把事件A传递给应用程序的主窗口（keyWindow）。 窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成） 如果想让某个view不能处理事件（或者说，事件传递到某个view那里就断了），那么可以通过刚才提到的三种方式。比如，设置其userInteractionEnabled = NO;那么传递下来的事件就会由该view的父控件处理。所以，不管视图能不能处理事件，只要点击了视图就都会产生事件，关键在于该事件最终是由谁来处理！ 如果设置父控件的透明度或者hidden，会直接影响到子控件的透明度和hidden。如果父控件的透明度为0或者hidden = YES，那么子控件也是不可见的！ 如何寻找最合适的View 在寻找合适的View时，怎么来判断当前的View是否合适呢？ 有两个重要的方法： - (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; - (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event; hitTest：withEvent：方法 方法的调用时机：只要事件一传递给一个控件,这个控件就会调用他自己的hitTest：withEvent：方法。 方法的作用：返回最合适的view(能够响应事件的那个最合适的view)。 正因为hitTest：withEvent：方法可以返回最合适的view，所以可以通过重写hitTest：withEvent：方法，返回指定的view作为最合适的view。 不管点击哪里，最合适的view都是hitTest：withEvent：方法中返回的那个view。 通过重写hitTest：withEvent：，就可以拦截事件的传递过程，返回的View就是事件的处理者。 如果hitTest:withEvent:方法中返回nil，那么调用该方法的控件本身和其子控件都不是最合适的view，也就是在自己身上没有找到更合适的view。那么最合适的view就是该控件的父控件。 不管子控件是不是最合适的view，系统默认都要先把事件传递给子控件，经过子控件调用子控件自己的hitTest:withEvent:方法验证后才知道有没有更合适的view。即便父控件是最合适的view了，子控件的hitTest:withEvent:方法还是会调用，不然怎么知道有没有更合适的！即，如果确定最终父控件是最合适的view，那么该父控件的子控件的hitTest:withEvent:方法也是会被调用的。 hit:withEvent:方法底层会调用pointInside:withEvent:方法判断点在不在方法调用者的坐标系上。 pointInside:withEvent:方法 方法的调用时机：调用hitTest:withEvent:方法时回调用pointInside:withEvent:方法判断点在不在方法调用者的坐标系上。 方法的作用：方法判断点在不在当前view上（方法调用者的坐标系上）如果返回YES，代表点在方法调用者的坐标系上;返回NO代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。 方法的调用关系 首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内。若pointInside:withEvent:方法返回NO，说明触摸点不在当前视图内，则当前视图的hitTest:withEvent:返回nil。若pointInside:withEvent:方法返回YES，说明触摸点在当前视图内，则遍历当前视图的所有子视图(subviews)，调用子视图的hitTest:withEvent:方法重复前面的步骤。子视图的遍历顺序是从top到bottom，即从subviews数组的末尾向前遍历，直到有子视图的hitTest:withEvent:方法返回非空对象或者全部子视图遍历完毕。 若第一次有子视图的hitTest:withEvent:方法返回非空对象,则当前视图的hitTest:withEvent:方法就返回此对象，处理结束。若所有子视图的hitTest:withEvent:方法都返回nil，则当前视图的hitTest:withEvent:方法返回当前视图自身(self)。 这个触摸事件交给主窗口的hitTest:withEvent:方法返回的视图对象去处理。 事件的响应 当View是合适的View，且接受到事件后，就会就进行事件的响应，而事件的响应就是调用touchBegan等方法。而这些方法的默认做法就是事件顺着响应者链条向上传递。 响应者链条 如果当前这个view是控制器的view,那么控制器就是上一个响应者 如果当前这个view不是控制器的view,那么父控件就是上一个响应者 按照上面方法找到最上层的响应者，从而形成一个响应者的链条。 响应者链的事件传递过程: 如果当前view是控制器的view，那么控制器就是上一个响应者，事件就传递给控制器；如果当前view不是控制器的view，那么父视图就是当前view的上一个响应者，事件就传递给它的父视图，如果当前的响应者不能处理此事件，则就是继续上传到上一个响应者。 当传到视图层次结构的最顶级视图后，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理。 如果window对象也不处理，则其将事件或消息传递给UIApplication对象。 如果UIApplication也不能处理该事件或消息，则将其丢弃。 总结 事件处理的整个流程总结： 触摸屏幕产生触摸事件后，触摸事件会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。 UIApplication会从事件队列中取出最前面的事件，把事件传递给应用程序的主窗口（keyWindow）。 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件。（至此，第一步已完成) 最合适的view会调用自己的touches方法处理事件 touches默认做法是把事件顺着响应者链条向上抛。 事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件）。 官方的文档 ","link":"http://localhost:4000/post/ios-zhong-de-xiang-ying-lian/"},{"title":"iOS中的锁","content":"先占个位，过阵好好的写一下 NSRecursiveLock递归锁 一般用于递归调用锁的情况，看一下如下代码 当RecursiveMethod方法调用第二次的时候，就会发生死锁，因为普通的NSLock只能在同一线程里调用一次，而NSRecursiveLock支持在同一线程里多次调用锁 互斥锁和自旋锁 互斥锁： 一种用来防止多个线程同一时刻对共享资源进行访问的信号量，它的原子性确保了如果一个线程锁定了一个互斥量，将没有其他线程在同一时间可以锁定这个互斥量。它的唯一性确保了只有它解锁了这个互斥量，其他线程才可以对其进行锁定。当一个线程锁定一个资源的时候，其他对该资源进行访问的线程将会被挂起，直到该线程解锁了互斥量，其他线程才会被唤醒，进一步才能锁定该资源进行操作。 自旋锁： 和互斥锁类似，都是为了保证线程安全的锁。但二者的区别是不一样的，对于互斥锁，当一个线程获得这个锁之后，其他想要获得此锁的线程将会被阻塞，直到该锁被释放。但自选锁不一样，当一个线程获得锁之后，其他线程将会一直循环在哪里查看是否该锁被释放。所以，此锁比较适用于锁的持有者保存时间较短的情况下。 ","link":"http://localhost:4000/post/ios-zhong-de-suo/"},{"title":"iOS中的绘图","content":"CoreGraphics,QuartzCore,CoreAnimation区别 CoreGraphics iOS的核心图形库，包含 Quartz2D 绘图API接口,常用的是point，size，rect等这些图形，都定义在这个框架中，类名以CG开头的都属于 CoreGraphics 框架，它提供的都是C语言函数接口，是可以在iOS和mac OS 通用的。iOS系统本身提供了两套绘图的框架，即UIBezierPath 和 Core Graphics。而前者所属UIKit，其实是对 Core Graphics 框架关于path的进一步封装，所以使用起来比较简单。但是毕竟Core Graphics更接近底层，所以它更加强大。 QuartzCore QuartzCore(包含CoreAnimation）框架，是iOS系统的基本渲染框架，是一个OC语言框架，是一套基于CoreGraphics的OC语言封装，封装出了基本渲染类CALayer。 CoreAnimation CoreAnimation翻译过来就是核心动画,一组非常强大的API，用来做动画的，非常的简单，但是效果非常绚丽。 CoreAnimation是跨平台的，既可以支持iOS，也支持MAC OS。 CoreAnimation执行动画是在后台，不会阻塞主线程。 CoreAnimation作用在CALayer，不是UIView。 CoreGraphics和CoreAnimation的关系：它们都是跨iOS和Mac OS 使用的，这点区别于UIKit，并且CoreAnimation中大量使用到CoreGraphics中的类，因为实现动画要用到图形库中的东西。 可以看出，CoreGraphics是底层绘制框架，我们实际会用到的也就是CG开头的一些底层绘制函数和变量，这是一个纯C语言框架。 CALayer和CGLayer的区别 UIView是对CALayer的一层封装，拥有的交互能力。 CGLayer是在Core Graphics中的涂层，类似bitmap，可以缓存图像，直接用于GPU绘制 stackoverflow回答 一般图层的占用空间 图层宽*图层高*4字节，宽高的单位均为像素 GPU渲染机制 CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 On-Screen Rendering 和 Off-Screen Rendering On-Screen Rendering 意为当前屏幕渲染，指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区中进行。 Off-Screen Rendering 意为离屏渲染，指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。 特殊的 Off-Screen Rendering 如果将不在GPU的当前屏幕缓冲区中进行的渲染都称为离屏渲染，那么就还有另一种特殊的“离屏渲染”方式：CPU渲染。 CPU渲染:如果我们重写了drawRect方法，并且使用任何Core Graphics的技术进行了绘制操作，就涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。 离屏渲染的代价 创建新缓冲区要想进行离屏渲染，首先要创建一个新的缓冲区。 上下文切换：离屏渲染的整个过程，需要多次切换上下文环境：先是从当前屏幕（On-Screen）切换到离屏（Off-Screen）；等到离屏渲染结束以后，将离屏缓冲区的渲染结果显示到屏幕上有需要将上下文环境从离屏切换到当前屏幕。而上下文环境的切换是要付出很大代价的。 离屏渲染触发方式 设置了以下属性时，都会触发离屏绘制： shouldRasterize（光栅化） masks（遮罩） shadows（阴影） edge antialiasing（抗锯齿） group opacity（不透明） 需要注意的是，如果shouldRasterize被设置成YES，在触发离屏绘制的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。这将在很大程度上提升渲染性能。 渲染方式的选择 尽量使用当前屏幕渲染 离屏渲染带来了更大的消耗。而CPU渲染对于离屏渲染来说，由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染；但如果仅仅是实现一个简单的效果，直接使用CPU渲染的效率又可能比离屏渲染好，毕竟离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。因此特殊情况要特殊对待。 ","link":"http://localhost:4000/post/ios-zhong-de-hui-tu/"},{"title":"iOS中的动画","content":"之前整理了iOS的动画种类，后面会每个在学习一下。先把结构图传上来。 Layer的渲染架构 Layer也和View一样存在着一个层级树状结构,称之为图层树(Layer Tree),直接创建的或者通过UIView获得的(view.layer)用于显示的图层树,称之为模型树(Model Tree),模型树的背后还存在两份图层树的拷贝,一个是呈现树(Presentation Tree),一个是渲染树(Render Tree). 呈现树可以通过普通layer(其实就是模型树)的layer.presentationLayer获得,而模型树则可以通过modelLayer属性获得(详情文档).模型树的属性在其被修改的时候就变成了新的值,这个是可以用代码直接操控的部分;呈现树的属性值和动画运行过程中界面上看到的是一致的.而渲染树是私有的,你无法访问到,渲染树是对呈现树的数据进行渲染,为了不阻塞主线程,渲染的过程是在单独的进程或线程中进行的,所以你会发现Animation的动画并不会阻塞主线程。 ","link":"http://localhost:4000/post/ios-zhong-de-dong-hua/"},{"title":"iOS杂项","content":"attribute((always_inline)) 今天看到一个函数用__attribute__((always_inline))修饰 static __attribute__((always_inline)) void disable_gdb(UCARSecurityCheckFinish checkBlock) { void* handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW); // ptrace NSString* ptrace = confusion_NSSTRING(((unsigned char []) {0x34, 0x58, 0x35, 0x2B, 0xFA, 0x17}), 6); ptrace_ptr_t ptrace_ptr = dlsym(handle, ptrace.UTF8String); if (checkBlock) { ucar_imp_ptrace_check((IMP)ptrace_ptr, checkBlock); } ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0); dlclose(handle); } 特地查了下这个修饰的含义： 加入了__attribute__((always_inline))修饰代表着这个函数被强制内联。如果一个A函数调用了这个B（强制内联）函数，那么执行到调用B函数时，不是跳转到这个B函数，而是B函数的函数题直接直接作为A函数体的一部分。 autorelease 苹果的Atuorelease实现就是把对象加到释放池 NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END 被这两个宏包含的对象都是 nonnull，就是不能为空值。 atomic atomic能保证setter和getter是原子性的，但不能保证是线程安全，因为多个线程写操作，一个线程读操作，那么不能保证读的操作的值是准确的 _变量和self. 在对象内部尽量直接访问实例变量 不要在init和dealloc方法中调用accessor（存取器）方法（因为在子类初始化的时候，会调用父类初始化，父类初始化可能也会调用setter或getter，而此时调用的是子类的setter或getter，此时子类的setter或getter的实现是基于子类还没有初始化完成，因此可能出错）。 宏定义和静态变量 所有的宏在被编译之前都会被其定义替换掉，就是说如果一个宏的定义是一串很长的代码，而且这个宏被多次使用，那么编译后将会使用该宏的定义替换掉那些使用宏的地方，所以就会出现很多重复的代码，这是很低效的。但是如果宏的定义比较简短，比如就是一个值，那么可以直接使用宏。 静态变量就不会有替换问题了，但是静态变量在运行的时候系统会在栈上为其分配内存，一直到程序结束才会被销毁。而且静态变量只能存储值，而不能定义操作，而宏的定义既可以是一个值，也可以是一系列操作。 如果一个值使用次数不多，或者希望执行一系列操作而又不想定义函数的话使用宏是不错的选择。 如果一个值使用次数比较频繁，则推荐使用静态变量。 UISwitch 默认大小 iOS7及其以后的UISwitch默认大小是51x31， iOS7之前UISwitch默认大小是79x27 为什么iOS更新UI操作必须在主线程 UI操作涉及到渲染访问各种View对象的属性，如果是异步操作会有读写问题。加锁呢，性能损耗大(视图层次深，属性多)。所以主线程操作UI，是约定俗成的开发规则。 还有人是这么解释的： &quot;The first one is that, in Cocoa Touch, the UIApplication gets set up on the main thread Another reason is graphics rendering: the graphics pipeline of the iPhone is ultimately synchronous.&quot; 1.在Cocoa Touch框架中，UIApplication初始化工作是在主线程进行的。而界面上所有的视图都是在UIApplication 实例的叶子节点(内存管理角度)。 2.图形渲染在iPhone设备本质上是同步的。图形渲染计算最终要显示的像素值，以每秒60帧的频率刷新到屏幕上，绘制到屏幕的过程实际上就是通过LED display点亮各个像素。这个过程需要一次将所有将要实现的像素刷新到屏幕上(同时的)。如果要异步化的话，对应的你无法确定这个处理过程是否真正的全部完成。 优先级反转的现象 比如两个线程 A 和 B，优先级 A &lt; B。当 A 获取锁访问共享资源时，B 尝试获取锁，那么 B 就会进入忙等状态，忙等时间越长对 CPU 资源的占用越大；而由于 A 的优先级低于 B，A 无法与高优先级的线程争夺 CPU 资源，从而导致任务迟迟完成不了。这样就导致了死锁。 OSSpinLock 自旋锁的伪代码 bool lock = false; // 一开始没有锁上，任何线程都可以申请锁 do { while(test_and_set(&amp;lock); // test_and_set 是一个原子操作 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 } 如果线程没有获得锁，那么相当于一直在循环等待，等待锁的持有者释放。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率高于互斥锁。 自旋锁一直占用CPU，在未获得锁的情况下，一直运行（自旋），所以占用着CPU，如果不能在很短的时间内获得锁，这无疑会使CPU效率降低。所以自旋锁适用于锁使用者保持锁时间比较短的情况下。 信号量（） 信号量的伪代码 int sem_wait (sem_t *sem) { int *futex = (int *) sem; if (atomic_decrement_if_positive (futex) &gt; 0) return 0; int err = lll_futex_wait (futex, 0); return -1; ) 具体的等待操作在 lll_futex_wait 函数中实现，lll 是 low level lock 的简称。这个函数通过汇编代码实现，调用到 SYS_futex 这个系统调用，使线程进入睡眠状态，主动让出时间片，让别的线程进行操作。主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。 pthread_mutex 这个锁和信号量类似，也是通过上锁后阻塞其他线程，并使之睡眠，让出时间片，也调用了 lll_futex_wait 函数。 而上述所得效率大概为：OSSpinLock &gt; 信号量 &gt; pthread_mutex &gt; 其他类型的锁 OSSpinLock和信号量的实现都比较简单所以，效率都比较高，而它俩的效率区别基本和上锁区域的任务大小有关。 而pthread_mutex之所以比信号量慢是因为pthread_mutex有多种类型，所以在加锁时需要对类型进行判断，所以效率要比信号量要略低。而锁的效率基本和锁的实现的复杂度有关，也就是越复杂，效率就越低。 OSSpinLock 不在安全 OSSpinLock 不在安全 YY大神的文章。 具体原因就是会出现上面的优先级反转的问题，因此最终的结论就是，除非开发者能保证访问锁的线程全部都处于同一优先级，否则 iOS 系统中所有类型的自旋锁都不能再使用了。 YYCache 中的磁盘缓存 YYCache https://blog.ibireme.com/2015/10/26/yycache/ 磁盘缓存分为三类： 基于文件读写 TMDiskCache, PINDiskCache, SDWebImage 等缓存，都是基于文件系统的，即一个 Value 对应一个文件，通过文件读写来缓存数据。他们的实现都比较简单，性能也都相近，缺点也是同样的：不方便扩展、没有元数据、难以实现较好的淘汰算法、数据统计缓慢。 基于 mmap 文件内存映射 FastImageCache 采用的是 mmap 将文件映射到内存。用过 MongoDB 的人应该很熟悉 mmap 的缺陷：热数据的文件不要超过物理内存大小，不然 mmap 会导致内存交换严重降低性能；另外内存中的数据是定时 flush 到文件的，如果数据还未同步时程序挂掉，就会导致数据错误。抛开这些缺陷来说，mmap 性能非常高。 基于数据库 NSURLCache、FBDiskCache 都是基于 SQLite 数据库的。基于数据库的缓存可以很好的支持元数据、扩展方便、数据统计速度快，也很容易实现 LRU 或其他淘汰算法，唯一不确定的就是数据库读写的性能，为此我评测了一下 SQLite 在真机上的表现。iPhone 6 64G 下，SQLite 写入性能比直接写文件要高，但读取性能取决于数据大小：当单条数据小于 20K 时，数据越小 SQLite 读取性能越高；单条数据大于 20K 时，直接写为文件速度会更快一些。这和 SQLite 官网的描述基本一致。另外，直接从官网下载最新的 SQLite 源码编译，会比 iOS 系统自带的 sqlite3.dylib 性能要高很多。基于 SQLite 的这种表现，磁盘缓存最好是把 SQLite 和文件存储结合起来：key-value 元数据保存在 SQLite 中，而 value 数据则根据大小不同选择 SQLite 或文件存储。NSURLCache 选定的数据大小的阈值是 16K；FBDiskCache 则把所有 value 数据都保存成了文件。 一段代码 LOCK( if (_buffer.count) { NSMutableDictionary *holder = _buffer; _buffer = [NSMutableDictionary new]; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^{ // Capture the dictionary to global queue, // release these images in background to avoid blocking UI thread. [holder class]; }); } ); YYWebImage中的一段代码，可以看出，意思是holder要在子线程进行释放，避免阻塞主线程，原来还有这种操作，有点厉害。 ","link":"http://localhost:4000/post/ios-za-xiang/"},{"title":"iOS属性修饰符","content":"ARC中有5个参数 1.assign 2.strong 3.unsafe_unretained 4.copy 5.weak MRC中的retain assign assign一般用于非对象类型，直接为值拷贝，对引用计数不会影响。也可以用在对象类型，但是一旦对象被其他地方销毁掉，那就会成为野指针，造成程序崩溃。 strong strong类似在ARC情况的retain，会增加引用计数，只能用于对象类型。strong的特点是，用strong修饰的对象，只要有一个strong类型的指针引用，系统就不会出发改对象的dealloc。 unsafe_unretained unsafe_unretained用于对象类型，不会影响对象的引用计数。特点是，当修饰的对象被销毁掉后，该指针就会成为野指针。之所以存在这个属性是因为，这个引用的属性在内存管理的效率高于weak。用的时候需要注意这个指针指向的对象销毁掉后，其他的地方需要保证不能在使用这个指针。 copy copy用于对象类型，常用于Block和String。而Block和String两者都可以用与Copu和Strong修饰。Block用strong修饰和copy是一样的效果，内部实现均进行了copy，copy后Block会从栈区拷贝到堆区。String可用Strong也可用Copy修饰，主要是场景不同，strong修饰的String不会产生新对象和新指针，因此如果原先的对象被修改，此时指向的对象也会受到影响，如果有类似需求可以用strong修饰。而copy对于NSString来说和strong也十分类似，但是如果赋值时传入的是MutablString则不同，用与copy修饰后，会深拷贝一个不可变对象出来，因此这个对象不会受到原先对象改变的影响。 weak weak与assign十分类似，也不会增加对象的引用计数，相当直接获取到了对象的引用。不同的是，weak用对象类型，不能用与非对象类型。而weak引用的对象如果在其他地方被销毁掉后，此时的weak不会变成野指针，而是被自动的置为nil。 retain retain与copy相似，但是不同的是，copy是实现了拷贝，重新成了一个对象并使引用计数+1，而retain是直接使原来的对象引用计数+1。 在看YYCache的原理时发现，在实现LRU算法的同时，对属性使用的是unsafe_unretained，而没有使用weak。原因是，在读取weak属性时，系统内部会调用objc_loadWeak()和objc_storeWeak()方法，这会具有额外的开销。因此，如果在需要性能的时候，应该使用unsafe_unretained，在需要安全稳定简单的时候使用weak。 ","link":"http://localhost:4000/post/ios-shu-xing-xiu-shi-fu/"},{"title":"iOS编译","content":"iOS 编译步骤 预处理（Pre-process）：把宏替换，删除注释，展开头文件，产生 .i 文件。 编译（Compliling）：把之前的 .i 文件转换成汇编语言，产生 .s文件。 汇编（Asembly）：把汇编语言文件转换为机器码文件，产生 .o 文件。 链接（Link）：对.o文件中的对于其他的库的引用的地方进行引用，生成最后的可执行文件（同时也包括多个 .o 文件进行 link）。 iOS 开发中 Objective-C 和 Swift 都用的是 Clang / LLVM 来编译的。LLVM是一个模块化和可重用的编译器和工具链技术的集合。Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是 Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。 编译信息写入辅助文件，创建文件架构 .app 文件 处理文件打包信息 执行 CocoaPod 编译前脚本，checkPods Manifest.lock 编译.m文件，使用 CompileC 和 clang 命令 链接需要的 Framework 编译 xib 拷贝 xib ，资源文件 编译 ImageAssets 处理 info.plist 执行 CocoaPod 脚本 拷贝标准库 创建 .app 文件和签名 ","link":"http://localhost:4000/post/ios-bian-yi/"},{"title":"Homebrew命令","content":"查看已经安装的包 brew list 要获取最新的包的列表 brew update 完后会显示可以更新的包列表，其中打钩的是已经安装的包。 查看哪些包可以更新。 brew outdated 更新包 然后就可以用 brew upgrade 去更新了。Homebrew 会安装新版本的包，但旧版本仍然会保留 brew upgrade # 更新所有的包 brew upgrade $FORMULA # 更新指定的包 清理旧版本 新版本安装了，旧版本就不需要了。我会用 brew cleanup 清理旧版本和缓存文件。Homebrew 只会清除比当前安装的包更老的版本，所以不用担心有些包没更新但被删了。 brew cleanup # 清理所有包的旧版本 brew cleanup $FORMULA # 清理指定包的旧版本 brew cleanup -n # 查看可清理的旧版本包，不执行实际操作 现在该更新的都更新了，旧版本也被清理。 对于Homebrew来说，如果没有卸载掉软件包的所有版本，那么Homebrew会继续尝试安装这个软件包的最新版本。要想彻底卸载某个软件包，需要执行命令： brew uninstall formula_name --force 锁定不想更新的包 如果经常更新的话，brew update 一次更新所有的包是非常方便的。但我们有时候会担心自动升级把一些不希望更新的包更新了。数据库就属于这一类，尤其是 PostgreSQL 跨 minor 版本升级都要迁移数据库的。我们更希望找个时间单独处理它。这时可用 brew pin 去锁定这个包，然后 brew update 就会略过它了。 brew pin $FORMULA # 锁定某个包 brew unpin $FORMULA # 取消锁定 几个常用命令 brew info 可以查看包的相关信息，最有用的应该是包依赖和相应的命令。比如 Nginx 会提醒你怎么加 launchctl ，PostgreSQL 会告诉你如何迁移数据库。这些信息会在包安装完成后自动显示，如果忘了的话可以用这个命令很方便地查看。 brew info $FORMULA # 显示某个包的信息 brew info # 显示安装了包数量，文件数量，和总占用空间 brew deps 可以显示包的依赖关系，我常用它来查看已安装的包的依赖，然后判断哪些包是可以安全删除的。 brew deps --installed --tree # 查看已安装的包的依赖，树形显示 ","link":"http://localhost:4000/post/homebrew-ming-ling/"},{"title":"Git相关指令","content":"删除远程分支 git push origin --delete 分支名字 删除本地分支 git branch -d 分支名字 创建tag git tag -a 版本号 -m '版本说明' 推送单个tag git push origin tag名称 推送所有tag git push origin —-tag 或者 git push —-tag 取消本地目录下关联的远程库 git remote remove origin 在本地目录下关联远程repository git remote add origin 仓库地址 clone git clone 仓库地址 指定名城 恢复本地所有更改 git checkout . git reset . 本地分支重命名 git branch -m 旧分支名字 新分支名字 推送commit ，之后就可以直接使用 git push 命令来提交 git push -u origin master 推送本地分支 git push origin 分支名称 关联分支 git push --set-upstream origin 分支名称 在已有分支上创建分支 git checkout -b 分支名称 本地分支关联远程分支重置 git branch --unset-upstream 本地分支关联远程分支 git branch --set-upstream origin 本地分支名称 查看log 并带有文件修改 git log -p 查看log 图形化 git log --graph 查看当前分支log 图形化 git log 当前分支名称 --graph 回滚文件提交 git revert 提交id （产生commit） Git reset --hard 提交id （直接重置，中间的记录被清除掉） 创建stash git stash git stash save 'stash名字' 应用stash git stash apply tag的index或者stash名字 移除stash git stash drop tag的index或者stash名字 移出stash并应用 git stash pop tag的index或者stash名字 ","link":"http://localhost:4000/post/git-xiang-guan-zhi-ling/"},{"title":"Elasticsearch学习","content":"空搜索 GET /_search 搜索API的最基础的形式是没有指定任何查询的空搜索 ，它简单地返回集群中所有索引下的所有文档 返回文档包含的字段： hits 返回结果中最重要的部分是 hits ，它 包含 total 字段来表示匹配到的文档总数，并且一个 hits 数组包含所查询结果的前十个文档。在 hits 数组中每个结果包含文档的 _index 、 _type 、 _id ，加上 _source 字段。这意味着我们可以直接从返回的搜索结果中使用整个文档。这不像其他的搜索引擎，仅仅返回文档的ID，需要你单独去获取文档。每个结果还有一个 _score ，它衡量了文档与查询的匹配程度。默认情况下，首先返回最相关的文档结果，就是说，返回的文档是按照 _score 降序排列的。在这个例子中，我们没有指定任何查询，故所有的文档具有相同的相关性，因此对所有的结果而言 1 是中性的 _score 。max_score 值是与查询所匹配文档的 _score 的最大值。 took took值告诉我们执行整个搜索请求耗费了多少毫秒。 shards 告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。正常情况下我们不希望分片失败，但是分片失败是可能发生的。如果我们遭遇到一种灾难级别的故障，在这个故障中丢失了相同分片的原始数据和副本，那么对这个分片将没有可用副本来对搜索请求作出响应。假若这样，Elasticsearch 将报告这个分片是失败的，但是会继续返回剩余分片的结果。 timeout 告诉我们查询是否超时。默认情况下，搜索请求不会超时。 如果低响应时间比完成结果更重要，你可以指定 timeout 为 10 或者 10ms（10毫秒），或者 1s（1秒）： GET /_search?timeout=10ms ","link":"http://localhost:4000/post/elasticsearch-xue-xi/"},{"title":"DTCoreText学习","content":" CoreText会把一行里连在一起相同属性的文字合在一起作为一个CTRun，每一行是一个CTLine，多行合在一起组成CTFrame。如上图，第一行的文字有两种样式，第一部分是加粗，第二部分是斜体，因为样式不同所以分成了两个CTRun，CTLine包含了这两个CTRun，CTFrame包含了所有CTLine。 DT结构 最上层是使用者，可以是Controller，例如项目里示例的DemoTextViewController，也可以是某视图类。接着是DTCoreText封装好的各个控件，自带的有Label，TextView和Cell，这些控件的文字渲染都由DTAttributedTextContentView负责，非文字部分例如图片/视频等元素会在上层使用者那里通过delegate传给DTAttributedTextContentView。DTCoreTextLayouter / DTCoreTextLayoutFrame / DTCoreTextLayoutLine / DTCoreTextGlyphRun这四个类分别对应CoreText里的CTFramesetter / CTFrame / CTLine / CTRun，模仿了CoreText的模式，功能和作用一样，只是在它们基础上添加了功能。接下来看看每一个类具体做了什么事情。 DTAttributedTextContentView 这个是显示的文本整体的view 功能： 1.生成DTCoreTextLayoutFrame并绘制，通过上层传进来的NSAttributeString生成DTCoreTextLayouter和DTCoreTextLayoutFrame，进行各种配置后用DTCoreTextLayoutFrame渲染文字到当前layer上，这些配置包括 是否显示图片链接/限定行数/断行规则等。 2.处理Attachment和Link，在 -layoutSubviewsInRect: 方法里遍历DTCoreTextLayoutFrame里的每一个DTCoreTextGlyphRun，找出有附件和链接的Run进行处理，附件包括图片/视频等，创建这些附件对应的view，把这些view按DTCoreTextGlyphRun计算好的位置添加到专门存放附件和链接的customViews上完事。 DTCoreTextLayouter 功能：DTCoreTextLayouter 负责生成和缓存DTCoreTextLayoutFrame，相当于CTFramesetter和CTFrame的关系，做的事很简单，就是通过NSAttributeString生成CTFramesetter，再根据不同的rect生成DTCoreTextLayoutFrame，并缓存这些frame。 DTCoreTextLayoutFrame 功能：是最重要的一个类，负责渲染文字，主要做了两件事：生成行和渲染每一行。 DTCoreTextLayoutLine 功能：相当于CTLine,生成GlyphRun DTCoreTextGlyphRun 功能：相当于CTRun，渲染文字最基本单位。 ","link":"http://localhost:4000/post/dtcoretext-xue-xi/"},{"title":"copy和mutableCopy","content":"程序里的拷贝分为 1.浅拷贝 2.深拷贝 浅拷贝是直接创建了一个新的指针指向了原来的对象。这样两个指针指向了同一个对象。 深拷贝是直接创建了一个新的对象，并用一个新的指针指向。 对象可分为可变对象和不可变对象，Copy也有Copy和MutablCopy。 因此就有了四种组合： 1.对不可变对象进行Copy操作，此时是进行了浅拷贝。 2.对不可变对象进行MutableCopy操作，此时会进行深拷贝，且拷贝出来的对象为可变对象。 3.对可变对象进行Copy操作，此时是进行了深拷贝，拷贝出来的对象是不可变对象。 4.对可变对象进行MutableCopy操作，此时会进行深拷贝，且拷贝出来的对象为可变对象。 而需要注意的事情是，当对不可变对象执行了可变的操作时，就会引发崩溃。比如：对一个MutableString进行Copy操作，然后对生成的对象执行append操作就会崩溃，因为生成的对象是不可变的对象。 ","link":"http://localhost:4000/post/copy-he-mutablecopy/"},{"title":"AFN学习","content":"AFN2.X版本 AFN在进行网络请求时，把网络请求封装成了AFURLConnectionOperation，AFURLConnectionOperation基类是NSOperation，而在AFHTTPRequestOperationManager中创建了一个子线程，通过Runloop会使这个线程保活。 而所有请求的发起和回调都会在这个线程执行。 请求的发起时同步的，回调也是同步的。因为所有请求都是在一个线程中发起和回调，如果是异步的那么一定会开启另一条线程。 这里有个概念，如果是异步操作那么一定会开启线程 那么网络请求岂不变成了同步请求么？ 不是，因为AFN2.X中的网络请求的是基于NSURLConnection的。NSURLConnection 是被设计成异步发送的，调用了start方法后，NSURLConnection 会新建一些线程用底层的 CFSocket 去发送和接收请求。因此网络请求仍然是异步的。 AFN3.X版本 AFN3.X版本取消掉了常驻子线程，网络请求改成基于NSURLSession 而之所以不用常驻子线程，是因为NSURLSession自身是异步请求，同时可以设置回调的OperationQueue，因此通过设置一个OperationQueue实现了和AFN2.X版本同样的效果 这里需要注意的是AFN将OperationQueue的maxConcurrentOperationCount设置成了1，意思是将这个OperationQueue设置成串行队列。而AFN2.X因为回调是在同一个线程，因此也是串行回调的。这样做的目的就是保证数据操作的安全性。 这里要注意下maxConcurrentOperationCount设置成1只是将队列设置成串行队列，让Operation串行执行，但是线程是否会开启是由系统管理，有可能开启新线程，也有可能不开启。 ","link":"http://localhost:4000/post/afn-xue-xi/"},{"title":"字符编码","content":"字符集 字符集就是规定了某个文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系。如下图： 字符集只是一个规则集合的名字，对应到真实生活中，字符集就是对某种语言的称呼。例如：英语，汉语，日语。 字符编码 对于一个字符集来说要正确编码转码一个字符需要三个关键元素：字库表（character repertoire）、编码字符集（coded character set）、字符编码（character encoding form）。 字库表 字库表是一个相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。 编码字符集 包含了编码值code point的集合，每个编码值表示一个字符在字库中的位置。 字符编码 编码字符集中的每个字符和实际存储数值之间的转换关系。 用字库表和编码字符集就可以完成对字符的编码，那么字符编码的作用是什么呢？ 统一字库表的目的是为了能够涵盖世界上所有的字符，但实际使用过程中会发现真正用的上的字符相对整个字库表来说比例非常低。例如中文地区的程序几乎不会需要日语字符，而一些英语国家甚至简单的ASCII字库表就能满足基本需求。而如果把每个字符都用字库表中的序号来存储的话，每个字符就需要3个字节（这里以Unicode字库为例），这样对于原本用仅占一个字符的ASCII编码的英语地区国家显然是一个额外成本（存储体积是原来的三倍）。 而Unicode就是编码字符集,UTF-8就是字符编码 ASCII 码 上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了128个字符的编码，比如空格SPACE是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的一位统一规定为0。(1个字节byte代表这8个二进制位) 中文编码 GB2312 国家简体中文字符集，兼容ASCII。简体中文编码，一个汉字占用2个字节，理论上最多可以表示 256 x 256 = 65536 个符号。 GBK 它是GB2312的扩展，加入对繁体字的支持，兼容GB2312。支持简体及繁体中文，但对他国非拉丁字母语言还是有问题。 Unicode 上面的集中编码，都很局限，不能包含所有国家的字符。而Unicode编码就诞生了。为了表达任意语言的任意字符。它使用4字节的数字来表达每个字母、符号，或者表意文字(ideograph)。每个数字唯一代表在某种语言中使用的符号。 UTF-8 Unicode规定了字符编码的范围，但是字符在计算机的储存大小却没有规定，因此UTF-8就是规定了Unicode中的字符在计算机里存储的大小。 Little endian 和 Big endian 以汉字严为例，Unicode 码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，这就是 Big endian 方式；25在前，4E在后，这是 Little endian 方式。 这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-endian)敲开还是从小头(Little-endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。 第一个字节在前，就是&quot;大头方式&quot;（Big endian），第二个字节在前就是&quot;小头方式&quot;（Little endian）。 那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？ Unicode 规范定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做&quot;零宽度非换行空格&quot;（zero width no-break space），用FEFF表示。这正好是两个字节，而且FF比FE大1。 如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。 ","link":"http://localhost:4000/post/zi-fu-bian-ma/"},{"title":"小时候的动画片","content":"作为一个90后，感觉我经历过的时期算得上是非常美好的。想象自己的童年真的很开心。有着那么多好看，好玩的动画片。真的很幸运，见证了那么多经典的诞生。现在看当前的小孩子，他们出生在这个互联网时代，一出生旁边就有着iPad，iPhone，电脑。这时代的变化对小孩子来讲真的是好么？ 自我感觉，未来的孩子虽然能享受着科技的便利，但是也会失去童年的意义。想自己在童年时代那么多好玩的东西，对自己来说也是回忆，不想因为时间慢慢逝去而逐渐忘掉。因此，再次记录一些原来的看过的动画片名称。可以用来回忆，也可以以后挨个给自己的孩子看。 记忆中原来的动画片大多数都是在CCTV-1看的，大约是5，6点播。因为我是包头市的，所以在BTTV-2套也能看到 好多动画片。还有各个地方台也都会有不同的动画片。 小神仙与小仙女 蓝皮书和大脸猫 阿笨猫 对了还有什么小虎还乡，猫咪小贝啥的，反正我是不爱看，以后也不给小孩看了，哈哈。 佐木鸟伍迪 大头儿子小头爸爸 一定要老版的，最新版的是在辣眼睛，顺便说一下什么灰太狼啊，小猪佩奇啊，熊出没啊，反正我觉得没原来的动画片好看。 小糊涂神 记得反派叫大魔包，经常坐垃圾桶。 西游记 太经典了，记得原来过年求我爸给我买本西游记动画片的书，还经常让我把给我从公司带个铁棍啥的，幻想自己是孙悟空。 鸭子侦探 小精灵灰豆 这个很好看 海尔兄弟 这个片尾曲太魔性，打雷又下雨，阿嘞。 蓝猫淘气三千问 这个就算了，虽然是那种能讲科学的动画片，但是剧情太拖沓了，好几百集，完全看不完啊。 葫芦娃，宝莲灯，这个属于电影不是剧集，当然还是很好看。还记得当时看宝莲灯的时候我还在发烧，裹个被子看的。 这些大多数在7，8岁之前看的，后面看的就大多数是日本的动画片了。 先部分记录下，等哪天有时间在详细写。 数码宝贝 光能使者 中华小当家 神奇宝贝 七龙珠 百变小樱 四驱兄弟 围棋少年 名侦探柯南 机器猫 灌篮高手 铁甲小宝 铁胆火车侠 蜡笔小新 弹珠警察 山林小猎人 忍者神龟 星际恐龙 猛兽侠 ","link":"http://localhost:4000/post/xiao-shi-hou-de-dong-hua-pian/"},{"title":"微信大会有感","content":" 要有自己的判断力，而不是人云亦云，即使是全世界的人都在指责。 说这个有点马后炮的感觉，你一个大公司，当然可以坚持自己的原则，不会为了推广才推广，可是在中国有几个这样的公司呢。大部分还都是为了赚钱的养家糊口的小公司。不过我认为，让产品获得自然的生长方式是对的，而不是人为过多的干预它。 这点很同意 非常同意上面的观点，好的产品确实应该给用户带来便利而不是去剥夺用户的资源。 一旦产品有很强的侵略性，那么用户的抵触心里会很大，一旦有更有好的产品诞生， 那么用户转移的倾向会很大，就比如现在大家手机里安装的基本都是lite版，QQ国 际版迅雷简单版、夸克浏览器。为什么相比如原来的产品，这些更加友好，且更加简 单。还是那句话，更简单的就是更友好的，反而也是更难的。突然想到了百度，对比 谷歌，百度真是恶心透了，为了增加流量，还增加了一系列推广的内容，这些都是增加 了用户的搜索成本。真的是只有你让用户爽，用户才会让你爽，否则，你的产品真是不 会有人用，即使你前期的大量推广，最终也会失败。 ","link":"http://localhost:4000/post/wei-xin-da-hui-you-gan/"},{"title":"关于Block","content":"Block分为三种： 1.NSGlobalBlock 2.NSStackBlock 3.NSMallocBlock 全局Block存放在全局的静态区，当程序运行后，由系统自动回收。 一般创建的临时Block，存放在栈区里，通过Copy复制到堆区里变为堆Block MRC下block需要用copy修饰，但是在ARC下使用copy或strong修饰其实都一样，因为block的retain就是用copy来实现的。 1.block内部如果通过外面声明的强引用来使用，那么block内部会自动产生一个强引用指向所使用的对象。 2.block内部如果通过外面声明的弱引用来使用，那么block内部会自动产生一个弱引用指向所使用的对象。 copy属性为了保证其变量的封装性，防止可变类型赋值的时候被窜改，常用于NSString Block的内存地址显示在栈区,栈区的特点就是创建的对象随时可能被销毁,一旦被销毁后续再次调用空对象就可能会造成程序崩溃,在对block进行copy后,block存放在堆区.所以在使用Block属性时使用Copy修饰,而在ARC模式下,系统也会默认对Block进行copy操作。 ","link":"http://localhost:4000/post/guan-yu-block/"},{"title":"服务端杂项","content":"反向代理 反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器， 并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 CGI（Common Gateway Interface） 通用网关接口 localhost、127.0.0.1和0.0.0.0区别 localhost相当于本地地址的域名，在host文件里对本机的ip地址进行映射，一般指的是127.0.0.1。 127.0.0.1 这个地址通常分配给 loopback 接口。loopback 是一个特殊的网络接口(可理解成虚拟网卡)，用于本机中各个应用之间的网络交互。只要操作系统的网络组件是正常的，loopback就能工作。 0.0.0.0 相当于 this，指的是本机所有的 ip。在 Flask 的 run 方法执行时，一般执行的时 0.0.0.0 的 host。如果要是执行了 127.0.0.1 的地址，那么局域网中其他机器将无法访问。执行了 0.0.0.0 其他机器就能访问。 ","link":"http://localhost:4000/post/fu-wu-duan-za-xiang/"},{"title":"创建私有Pod库","content":"准备 首先需要有两个私有仓库 A仓库 -&gt; 是存pod索引的地方，cocoapod就是通过这个仓库里的文件来找到相应的资源文件 B仓库 -&gt; 存储仓库的源文件 如果以后想继续增加资源文件，还可以增加C仓库，然后依然通过A仓库来索引。 创建相应的私有仓库 在创建仓库的时候需要添加README.md 然后把A仓库推到cocoapods中 A仓库的目录结构官方推荐为 因此这个仓库的目录最好建立一个Specs的文件夹 pod repo add 名字 git地址 创建pod工程模版 pod lib create 工程文件 pod的资源文件放在Asset和Classes目录下，Asset存放图片等文件，Classes存放资源文件。 将pod工程模版的资源更改为自己的资源 更改模版工程里的podspec文件 验证podspec文件 pod spec lint pod lib lint 把pod工程模版上传的B仓库 git remote add origin 远程仓库地址 git push origin master git pull origin master --allow-unrelated-histories 解决冲突后 git add . git commit -m 'PrivateLib commit' git push origin master 将B仓库的的版本打tag，版本与podspec里的描述一致 git tag -a 0.1.0 -m ‘0.1.0' git push origin 0.1.0 将B仓库上传到A仓库 pod repo push 仓库名 podspec文件名 使用私有库需要加入资源地址 source ‘资源地址' source 'https://gitlab.com/xyh44934776/yhkit.git' ","link":"http://localhost:4000/post/chuang-jian-si-you-pod-ku/"}]}